#+TITLE: Implementing Microstate Accounting in Linux using EBPF
#+AUTHOR: Carlos Neira


Implement microstate accounting in Linux using bcc tools
Micro-state accounting gives you information where your process spends most
of it's time, a process could be in one of the five available states :

This is the patch that we could convert use with ebf code https://lwn.net/Articles/127296/
  #+begin_quote
  Microstate Accounting
---------------------

Timing data on threads at present is pretty crude:  when the timer
interrupt occurs, a tick is added to either system time or user time
for the currently running thread.  Thus in an unpacthed kernel one can
distinguish three timed states:  On-cpu in userspace, on-cpu in system
space, and not running.

The actual number of states is much larger.  A thread can be on a
runqueue or  the expired queue (i.e., ready to run but not running),
sleeping on a semaphore or on a futex, having its time stolen to
service an interrupt, etc., etc.

This patch adds timers per-state to each struct task_struct, so that
time in all these states can be tracked.  This patch contains the core
code do the timing, and to initialise the timers.  Subsequent patches
enable the code (by adding Kconfig options) and add hooks to track
state changes.
#+end_quote

  The only status that we have available in user-land is /proc/<pid>/schedstat
 https://www.kernel.org/doc/Documentation/scheduler/sched-stats.txt

 Here is the official site for the changes :

 http://www.gelato.unsw.edu.au/IA64wiki/MicroStateAccounting
